-- Objective of these tests is to ensure if IndexScan is being picked up when order by clause has columns that match
-- prefix of any existing btree indices. This is for queries with both order by and a limit.
-- Tests for queries with order by and limit on B-tree indices.
CREATE TABLE test_index_with_orderby_limit (a int, b int, c float, d int);
CREATE INDEX index_a on test_index_with_orderby_limit using btree(a);
CREATE INDEX index_ab on test_index_with_orderby_limit using btree(a, b);
CREATE INDEX index_bda on test_index_with_orderby_limit using btree(b, d, a);
CREATE INDEX index_c on test_index_with_orderby_limit using hash(c);
INSERT INTO test_index_with_orderby_limit select i, i-2, i/3, i+1 from generate_series(1,10000) i;
ANALYZE test_index_with_orderby_limit;
-- should use index scan
explain (costs off) select a from test_index_with_orderby_limit order by a limit 10;
                                    QUERY PLAN
----------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  Index Only Scan using index_a on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select a from test_index_with_orderby_limit order by a limit 10;
 a  
----
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
(10 rows)

-- order by using a hash indexed column, should use SeqScan
explain (costs off) select c from test_index_with_orderby_limit order by c limit 10;
                            QUERY PLAN
-------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: c
         ->  Limit
               ->  Sort
                     Sort Key: c
                     ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select c from test_index_with_orderby_limit order by c limit 10;
 c 
---
 0
 0
 1
 1
 1
 2
 2
 2
 3
 3
(10 rows)

-- should use index scan
explain (costs off) select b from test_index_with_orderby_limit order by b limit 10;
                                     QUERY PLAN
------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b
         ->  Limit
               ->  Index Only Scan using index_bda on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select b from test_index_with_orderby_limit order by b limit 10;
 b  
----
 -1
  0
  1
  2
  3
  4
  5
  6
  7
  8
(10 rows)

-- should use index scan
explain (costs off) select a, b from test_index_with_orderby_limit order by a, b limit 10;
                                    QUERY PLAN
-----------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a, b
         ->  Limit
               ->  Index Only Scan using index_ab on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select a, b from test_index_with_orderby_limit order by a, b limit 10;
 a  | b  
----+----
  1 | -1
  2 |  0
  3 |  1
  4 |  2
  5 |  3
  6 |  4
  7 |  5
  8 |  6
  9 |  7
 10 |  8
(10 rows)

-- should use index scan
explain (costs off) select b, d from test_index_with_orderby_limit order by b, d limit 10;
                                     QUERY PLAN
------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, d
         ->  Limit
               ->  Index Only Scan using index_bda on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select b, d from test_index_with_orderby_limit order by b, d limit 10;
 b  | d  
----+----
 -1 |  2
  0 |  3
  1 |  4
  2 |  5
  3 |  6
  4 |  7
  5 |  8
  6 |  9
  7 | 10
  8 | 11
(10 rows)

-- should use seq scan
explain (costs off) select d, b from test_index_with_orderby_limit order by d, b limit 10;
                            QUERY PLAN
-------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: d, b
         ->  Limit
               ->  Sort
                     Sort Key: d, b
                     ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select d, b from test_index_with_orderby_limit order by d, b limit 10;
 d  | b  
----+----
  2 | -1
  3 |  0
  4 |  1
  5 |  2
  6 |  3
  7 |  4
  8 |  5
  9 |  6
 10 |  7
 11 |  8
(10 rows)

-- should use seq scan
explain (costs off) select d, a from test_index_with_orderby_limit order by d, a limit 10;
                            QUERY PLAN
-------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: d, a
         ->  Limit
               ->  Sort
                     Sort Key: d, a
                     ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select d, a from test_index_with_orderby_limit order by d, a limit 10;
 d  | a  
----+----
  2 |  1
  3 |  2
  4 |  3
  5 |  4
  6 |  5
  7 |  6
  8 |  7
  9 |  8
 10 |  9
 11 | 10
(10 rows)

-- should use seq scan
explain (costs off) select a, c from test_index_with_orderby_limit order by a, c limit 10;
                            QUERY PLAN
-------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a, c
         ->  Limit
               ->  Sort
                     Sort Key: a, c
                     ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select a, c from test_index_with_orderby_limit order by a, c limit 10;
 a  | c 
----+---
  1 | 0
  2 | 0
  3 | 1
  4 | 1
  5 | 1
  6 | 2
  7 | 2
  8 | 2
  9 | 3
 10 | 3
(10 rows)

-- should use index scan
explain (costs off) select b, d, a from test_index_with_orderby_limit order by b, d, a limit 10;
                                     QUERY PLAN
------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, d, a
         ->  Limit
               ->  Index Only Scan using index_bda on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select b, d, a from test_index_with_orderby_limit order by b, d, a limit 10;
 b  | d  | a  
----+----+----
 -1 |  2 |  1
  0 |  3 |  2
  1 |  4 |  3
  2 |  5 |  4
  3 |  6 |  5
  4 |  7 |  6
  5 |  8 |  7
  6 |  9 |  8
  7 | 10 |  9
  8 | 11 | 10
(10 rows)

-- should use seq scan
explain (costs off) select b, d, c from test_index_with_orderby_limit order by b, d, c limit 10;
                            QUERY PLAN
-------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, d, c
         ->  Limit
               ->  Sort
                     Sort Key: b, d, c
                     ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select b, d, c from test_index_with_orderby_limit order by b, d, c limit 10;
 b  | d  | c 
----+----+---
 -1 |  2 | 0
  0 |  3 | 0
  1 |  4 | 1
  2 |  5 | 1
  3 |  6 | 1
  4 |  7 | 2
  5 |  8 | 2
  6 |  9 | 2
  7 | 10 | 3
  8 | 11 | 3
(10 rows)

-- should use seq scan
explain (costs off) select c, b, a from test_index_with_orderby_limit order by c, b, a limit 10;
                            QUERY PLAN
-------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: c, b, a
         ->  Limit
               ->  Sort
                     Sort Key: c, b, a
                     ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select c, b, a from test_index_with_orderby_limit order by c, b, a limit 10;
 c | b  | a  
---+----+----
 0 | -1 |  1
 0 |  0 |  2
 1 |  1 |  3
 1 |  2 |  4
 1 |  3 |  5
 2 |  4 |  6
 2 |  5 |  7
 2 |  6 |  8
 3 |  7 |  9
 3 |  8 | 10
(10 rows)

-- with offset and without limit
explain (costs off) select a  from test_index_with_orderby_limit order by a offset 9990;
                                 QUERY PLAN
----------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Index Only Scan using index_a on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(5 rows)

select a  from test_index_with_orderby_limit order by a offset 9990;
   a   
-------
  9991
  9992
  9993
  9994
  9995
  9996
  9997
  9998
  9999
 10000
(10 rows)

-- limit value in subquery
explain (costs off) select a from test_index_with_orderby_limit order by a limit (select min(a) from test_index_with_orderby_limit);
                                                         QUERY PLAN
----------------------------------------------------------------------------------------------------------------------------
 Limit
   InitPlan 2 (returns $1)  (slice2)
     ->  Result
           InitPlan 1 (returns $0)  (slice3)
             ->  Limit
                   ->  Gather Motion 3:1  (slice4; segments: 3)
                         Merge Key: test_index_with_orderby_limit_1.a
                         ->  Index Only Scan using index_a on test_index_with_orderby_limit test_index_with_orderby_limit_1
                               Index Cond: (a IS NOT NULL)
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: test_index_with_orderby_limit.a
         ->  Limit
               ->  Index Only Scan using index_a on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(14 rows)

select a from test_index_with_orderby_limit order by a limit (select min(a) from test_index_with_orderby_limit);
 a 
---
 1
(1 row)

-- offset value in a subquery
explain (costs off) select c from test_index_with_orderby_limit order by c offset (select 9990);
                         QUERY PLAN
-------------------------------------------------------------
 Limit
   InitPlan 1 (returns $0)  (slice2)
     ->  Result
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: test_index_with_orderby_limit.c
         ->  Sort
               Sort Key: test_index_with_orderby_limit.c
               ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(9 rows)

select c from test_index_with_orderby_limit order by c offset (select 9990);
  c   
------
 3330
 3330
 3331
 3331
 3331
 3332
 3332
 3332
 3333
 3333
(10 rows)

-- order by opposite to index sort direction
explain (costs off) select a from test_index_with_orderby_limit order by a desc limit 10;
                                        QUERY PLAN
-------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  Index Only Scan Backward using index_a on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select a from test_index_with_orderby_limit order by a desc limit 10;
   a   
-------
 10000
  9999
  9998
  9997
  9996
  9995
  9994
  9993
  9992
  9991
(10 rows)

-- order by opposite to nulls direction in index
explain (costs off) select a from test_index_with_orderby_limit order by a NULLS FIRST limit 10;
                            QUERY PLAN
-------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  Sort
                     Sort Key: a NULLS FIRST
                     ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select a from test_index_with_orderby_limit order by a NULLS FIRST limit 10;
 a  
----
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
(10 rows)

-- order by desc with nulls last
explain (costs off) select a from test_index_with_orderby_limit order by a desc NULLS LAST limit 10;
                            QUERY PLAN
-------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  Sort
                     Sort Key: a DESC NULLS LAST
                     ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select a from test_index_with_orderby_limit order by a desc NULLS LAST limit 10;
   a   
-------
 10000
  9999
  9998
  9997
  9996
  9995
  9994
  9993
  9992
  9991
(10 rows)

-- order by as sum of two columns, uses SeqScan with Sort
explain (costs off) select a, b from test_index_with_orderby_limit order by a+b, c limit 3;
                            QUERY PLAN
-------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: ((a + b)), c
         ->  Limit
               ->  Sort
                     Sort Key: ((a + b)), c
                     ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select a, b from test_index_with_orderby_limit order by a+b, c limit 3;
 a | b  
---+----
 1 | -1
 2 |  0
 3 |  1
(3 rows)

explain (costs off) select a+b as sum from test_index_with_orderby_limit order by sum limit 3;
                            QUERY PLAN
-------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: ((a + b))
         ->  Limit
               ->  Sort
                     Sort Key: ((a + b))
                     ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select a+b as sum from test_index_with_orderby_limit order by sum limit 3;
 sum 
-----
   0
   2
   4
(3 rows)

-- order by using column number
explain (costs off) select a from test_index_with_orderby_limit order by 1 limit 3;
                                    QUERY PLAN
----------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  Index Only Scan using index_a on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select a from test_index_with_orderby_limit order by 1 limit 3;
 a 
---
 1
 2
 3
(3 rows)

-- check if index-only scan is leveraged when required
set optimizer_enable_indexscan to off;
-- project only columns in the Index
explain (costs off) select b from test_index_with_orderby_limit order by b limit 10;
                                     QUERY PLAN
------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b
         ->  Limit
               ->  Index Only Scan using index_bda on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select b from test_index_with_orderby_limit order by b limit 10;
 b  
----
 -1
  0
  1
  2
  3
  4
  5
  6
  7
  8
(10 rows)

-- re-enable indexscan
set optimizer_enable_indexscan to on;
DROP TABLE test_index_with_orderby_limit;
-- Tests for queries with order by and limit considering sort & null directions.
CREATE TABLE test_index_with_sort_directions_on_orderby_limit (a int, b text, c float, d int, e text, f int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
-- single col index with default order
CREATE INDEX dir_index_a on test_index_with_sort_directions_on_orderby_limit using btree(a);
-- single col index with reverse order
CREATE INDEX dir_index_b on test_index_with_sort_directions_on_orderby_limit using btree(b desc);
-- single col index with opp nulls direction
CREATE INDEX dir_index_c on test_index_with_sort_directions_on_orderby_limit using btree(c nulls first);
-- multi col index all with asc
CREATE INDEX dir_index_bcd on test_index_with_sort_directions_on_orderby_limit using btree(b,c,d);
-- multi col index all with desc
CREATE INDEX dir_index_fde on test_index_with_sort_directions_on_orderby_limit using btree(f desc,d desc,e desc);
-- multi col index mixed case
CREATE INDEX dir_index_eda on test_index_with_sort_directions_on_orderby_limit using btree(e, d desc nulls last,a);
-- Covering index
CREATE INDEX dir_covering_index_eb ON test_index_with_sort_directions_on_orderby_limit(e desc) INCLUDE (b);
INSERT INTO test_index_with_sort_directions_on_orderby_limit select i, CONCAT('col_b', i)::text, i/3.2, i+1, CONCAT('col_e', i)::text, i+3 from generate_series(1,10000) i;
INSERT INTO test_index_with_sort_directions_on_orderby_limit values (null, null, null, null, null);
ANALYZE test_index_with_sort_directions_on_orderby_limit;
-- should use Forward IndexScan
explain (costs off) select a from test_index_with_sort_directions_on_orderby_limit order by a limit 3;
                                               QUERY PLAN
---------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  Index Only Scan using dir_index_a on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select a from test_index_with_sort_directions_on_orderby_limit order by a limit 3;
 a 
---
 1
 2
 3
(3 rows)

-- should use Backward IndexScan
explain (costs off) select a from test_index_with_sort_directions_on_orderby_limit order by a desc limit 3;
                                                    QUERY PLAN
------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  Index Only Scan Backward using dir_index_a on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select a from test_index_with_sort_directions_on_orderby_limit order by a desc limit 3;
   a   
-------
      
 10000
  9999
(3 rows)

-- should use SeqScan with Sort
explain (costs off) select a from test_index_with_sort_directions_on_orderby_limit order by a nulls first limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  Sort
                     Sort Key: a NULLS FIRST
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select a from test_index_with_sort_directions_on_orderby_limit order by a nulls first limit 3;
 a 
---
  
 1
 2
(3 rows)

explain (costs off) select a from test_index_with_sort_directions_on_orderby_limit order by a desc nulls last limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  Sort
                     Sort Key: a DESC NULLS LAST
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select a from test_index_with_sort_directions_on_orderby_limit order by a desc nulls last limit 3;
   a   
-------
 10000
  9999
  9998
(3 rows)

-- should use Forward IndexScan
explain (costs off) select b from test_index_with_sort_directions_on_orderby_limit order by b desc limit 3;
                                               QUERY PLAN
---------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b
         ->  Limit
               ->  Index Only Scan using dir_index_b on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select b from test_index_with_sort_directions_on_orderby_limit order by b desc limit 3;
     b     
-----------
 
 col_b9999
 col_b9998
(3 rows)

-- should use Backward IndexScan
explain (costs off) select b from test_index_with_sort_directions_on_orderby_limit order by b limit 3;
                                                    QUERY PLAN
------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b
         ->  Limit
               ->  Index Only Scan Backward using dir_index_b on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select b from test_index_with_sort_directions_on_orderby_limit order by b limit 3;
    b     
----------
 col_b1
 col_b10
 col_b100
(3 rows)

-- should use SeqScan with Sort
explain (costs off) select b from test_index_with_sort_directions_on_orderby_limit order by b nulls first limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b
         ->  Limit
               ->  Sort
                     Sort Key: b NULLS FIRST
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select b from test_index_with_sort_directions_on_orderby_limit order by b nulls first limit 3;
    b    
---------
 
 col_b1
 col_b10
(3 rows)

explain (costs off) select b from test_index_with_sort_directions_on_orderby_limit order by b desc nulls last limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b
         ->  Limit
               ->  Sort
                     Sort Key: b DESC NULLS LAST
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select b from test_index_with_sort_directions_on_orderby_limit order by b desc nulls last limit 3;
     b     
-----------
 col_b9999
 col_b9998
 col_b9997
(3 rows)

-- should use Forward IndexScan
explain (costs off) select c from test_index_with_sort_directions_on_orderby_limit order by c nulls first limit 3;
                                               QUERY PLAN
---------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: c
         ->  Limit
               ->  Index Only Scan using dir_index_c on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select c from test_index_with_sort_directions_on_orderby_limit order by c nulls first limit 3;
   c    
--------
       
 0.3125
  0.625
(3 rows)

-- should use Backward IndexScan
explain (costs off) select c from test_index_with_sort_directions_on_orderby_limit order by c desc nulls last limit 3;
                                                    QUERY PLAN
------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: c
         ->  Limit
               ->  Index Only Scan Backward using dir_index_c on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select c from test_index_with_sort_directions_on_orderby_limit order by c desc nulls last limit 3;
     c     
-----------
      3125
 3124.6875
  3124.375
(3 rows)

-- should use SeqScan with Sort
explain (costs off) select c from test_index_with_sort_directions_on_orderby_limit order by c limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: c
         ->  Limit
               ->  Sort
                     Sort Key: c
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select c from test_index_with_sort_directions_on_orderby_limit order by c  limit 3;
   c    
--------
 0.3125
  0.625
 0.9375
(3 rows)

explain (costs off) select c from test_index_with_sort_directions_on_orderby_limit order by c desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: c
         ->  Limit
               ->  Sort
                     Sort Key: c DESC
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select c from test_index_with_sort_directions_on_orderby_limit order by c desc limit 3;
     c     
-----------
          
      3125
 3124.6875
(3 rows)

-- should use Forward IndexScan
explain (costs off) select b,c,d from test_index_with_sort_directions_on_orderby_limit order by b,c,d limit 3;
                                                QUERY PLAN
-----------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, c, d
         ->  Limit
               ->  Index Only Scan using dir_index_bcd on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select b,c,d from test_index_with_sort_directions_on_orderby_limit order by b,c,d limit 3;
    b     |   c    |  d  
----------+--------+-----
 col_b1   | 0.3125 |   2
 col_b10  |  3.125 |  11
 col_b100 |  31.25 | 101
(3 rows)

explain (costs off) select b,c from test_index_with_sort_directions_on_orderby_limit order by b,c limit 3;
                                                QUERY PLAN
-----------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, c
         ->  Limit
               ->  Index Only Scan using dir_index_bcd on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select b,c from test_index_with_sort_directions_on_orderby_limit order by b,c limit 3;
    b     |   c    
----------+--------
 col_b1   | 0.3125
 col_b10  |  3.125
 col_b100 |  31.25
(3 rows)

-- should use Backward IndexScan
explain (costs off) select b,c,d from test_index_with_sort_directions_on_orderby_limit order by b desc,c desc,d desc limit 3;
                                                     QUERY PLAN
--------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, c, d
         ->  Limit
               ->  Index Only Scan Backward using dir_index_bcd on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select b,c,d from test_index_with_sort_directions_on_orderby_limit order by b desc,c desc,d desc limit 3;
     b     |     c     |   d   
-----------+-----------+-------
           |           |      
 col_b9999 | 3124.6875 | 10000
 col_b9998 |  3124.375 |  9999
(3 rows)

explain (costs off) select b,c from test_index_with_sort_directions_on_orderby_limit order by b desc,c desc limit 3;
                                                     QUERY PLAN
--------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, c
         ->  Limit
               ->  Index Only Scan Backward using dir_index_bcd on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select b,c from test_index_with_sort_directions_on_orderby_limit order by b desc,c desc limit 3;
     b     |     c     
-----------+-----------
           |          
 col_b9999 | 3124.6875
 col_b9998 |  3124.375
(3 rows)

-- should use SeqScan with Sort
explain (costs off) select b,c,d from test_index_with_sort_directions_on_orderby_limit order by b ,c desc,d desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, c, d
         ->  Limit
               ->  Sort
                     Sort Key: b, c DESC, d DESC
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select b,c,d from test_index_with_sort_directions_on_orderby_limit order by b ,c desc,d desc limit 3;
    b     |   c    |  d  
----------+--------+-----
 col_b1   | 0.3125 |   2
 col_b10  |  3.125 |  11
 col_b100 |  31.25 | 101
(3 rows)

explain (costs off) select b,c,d from test_index_with_sort_directions_on_orderby_limit order by b ,c ,d desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, c, d
         ->  Limit
               ->  Sort
                     Sort Key: b, c, d DESC
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select b,c,d from test_index_with_sort_directions_on_orderby_limit order by b ,c ,d desc limit 3;
    b     |   c    |  d  
----------+--------+-----
 col_b1   | 0.3125 |   2
 col_b10  |  3.125 |  11
 col_b100 |  31.25 | 101
(3 rows)

explain (costs off) select b,c,d from test_index_with_sort_directions_on_orderby_limit order by b desc, c ,d desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, c, d
         ->  Limit
               ->  Sort
                     Sort Key: b DESC, c, d DESC
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select b,c,d from test_index_with_sort_directions_on_orderby_limit order by b desc, c ,d desc limit 3;
     b     |     c     |   d   
-----------+-----------+-------
           |           |      
 col_b9999 | 3124.6875 | 10000
 col_b9998 |  3124.375 |  9999
(3 rows)

-- should use Forward IndexScan
explain (costs off) select f,d,e from test_index_with_sort_directions_on_orderby_limit order by f desc,d desc,e desc limit 3;
                                                QUERY PLAN
-----------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: f, d, e
         ->  Limit
               ->  Index Only Scan using dir_index_fde on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select f,d,e from test_index_with_sort_directions_on_orderby_limit order by f desc,d desc,e desc limit 3;
   f   |   d   |     e      
-------+-------+------------
       |       | 
 10003 | 10001 | col_e10000
 10002 | 10000 | col_e9999
(3 rows)

explain (costs off) select f,d from test_index_with_sort_directions_on_orderby_limit order by f desc,d desc limit 3;
                                                QUERY PLAN
-----------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: f, d
         ->  Limit
               ->  Index Only Scan using dir_index_fde on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select f,d from test_index_with_sort_directions_on_orderby_limit order by f desc,d desc limit 3;
   f   |   d   
-------+-------
       |      
 10003 | 10001
 10002 | 10000
(3 rows)

-- should use Backward IndexScan
explain (costs off) select f,d,e from test_index_with_sort_directions_on_orderby_limit order by f,d,e limit 3;
                                                     QUERY PLAN
--------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: f, d, e
         ->  Limit
               ->  Index Only Scan Backward using dir_index_fde on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select f,d,e from test_index_with_sort_directions_on_orderby_limit order by f,d,e limit 3;
 f | d |   e    
---+---+--------
 4 | 2 | col_e1
 5 | 3 | col_e2
 6 | 4 | col_e3
(3 rows)

explain (costs off) select f,d from test_index_with_sort_directions_on_orderby_limit order by f,d limit 3;
                                                     QUERY PLAN
--------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: f, d
         ->  Limit
               ->  Index Only Scan Backward using dir_index_fde on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select f,d from test_index_with_sort_directions_on_orderby_limit order by f,d limit 3;
 f | d 
---+---
 4 | 2
 5 | 3
 6 | 4
(3 rows)

-- should use SeqScan with Sort
explain (costs off) select f,d,e from test_index_with_sort_directions_on_orderby_limit order by f ,d desc,e desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: f, d, e
         ->  Limit
               ->  Sort
                     Sort Key: f, d DESC, e DESC
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select f,d,e from test_index_with_sort_directions_on_orderby_limit order by f ,d desc,e desc limit 3;
 f | d |   e    
---+---+--------
 4 | 2 | col_e1
 5 | 3 | col_e2
 6 | 4 | col_e3
(3 rows)

explain (costs off) select f,d,e from test_index_with_sort_directions_on_orderby_limit order by f,d ,e desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: f, d, e
         ->  Limit
               ->  Sort
                     Sort Key: f, d, e DESC
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select f,d,e from test_index_with_sort_directions_on_orderby_limit order by f,d ,e desc limit 3;
 f | d |   e    
---+---+--------
 4 | 2 | col_e1
 5 | 3 | col_e2
 6 | 4 | col_e3
(3 rows)

explain (costs off) select f,d,e from test_index_with_sort_directions_on_orderby_limit order by f desc, d ,e desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: f, d, e
         ->  Limit
               ->  Sort
                     Sort Key: f DESC, d, e DESC
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select f,d,e from test_index_with_sort_directions_on_orderby_limit order by f desc, d ,e desc limit 3;
   f   |   d   |     e      
-------+-------+------------
       |       | 
 10003 | 10001 | col_e10000
 10002 | 10000 | col_e9999
(3 rows)

-- should use Forward IndexScan
explain (costs off) select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e, d desc nulls last,a limit 3;
                                                QUERY PLAN
-----------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d, a
         ->  Limit
               ->  Index Only Scan using dir_index_eda on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e, d desc nulls last,a limit 3;
    e     |  d  |  a  
----------+-----+-----
 col_e1   |   2 |   1
 col_e10  |  11 |  10
 col_e100 | 101 | 100
(3 rows)

explain (costs off) select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e, d desc nulls last limit 3;
                                                QUERY PLAN
-----------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d
         ->  Limit
               ->  Index Only Scan using dir_index_eda on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e, d desc nulls last limit 3;
    e     |  d  |  a  
----------+-----+-----
 col_e1   |   2 |   1
 col_e10  |  11 |  10
 col_e100 | 101 | 100
(3 rows)

-- should use Backward IndexScan
explain (costs off) select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e desc,d nulls first,a desc limit 3;
                                                     QUERY PLAN
--------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d, a
         ->  Limit
               ->  Index Only Scan Backward using dir_index_eda on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e desc,d nulls first,a desc limit 3;
     e     |   d   |  a   
-----------+-------+------
           |       |     
 col_e9999 | 10000 | 9999
 col_e9998 |  9999 | 9998
(3 rows)

explain (costs off) select e,d from test_index_with_sort_directions_on_orderby_limit order by e desc,d nulls first limit 3;
                                                     QUERY PLAN
--------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d
         ->  Limit
               ->  Index Only Scan Backward using dir_index_eda on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select e,d from test_index_with_sort_directions_on_orderby_limit order by e desc,d nulls first limit 3;
     e     |   d   
-----------+-------
           |      
 col_e9999 | 10000
 col_e9998 |  9999
(3 rows)

-- should use SeqScan with Sort
explain (costs off) select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e, d desc,a desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d, a
         ->  Limit
               ->  Sort
                     Sort Key: e, d DESC, a DESC
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e, d desc,a desc limit 3;
    e     |  d  |  a  
----------+-----+-----
 col_e1   |   2 |   1
 col_e10  |  11 |  10
 col_e100 | 101 | 100
(3 rows)

explain (costs off) select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e desc,d desc,a desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d, a
         ->  Limit
               ->  Sort
                     Sort Key: e DESC, d DESC, a DESC
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e desc,d desc,a desc limit 3;
     e     |   d   |  a   
-----------+-------+------
           |       |     
 col_e9999 | 10000 | 9999
 col_e9998 |  9999 | 9998
(3 rows)

explain (costs off) select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e ,d ,a  limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d, a
         ->  Limit
               ->  Sort
                     Sort Key: e, d, a
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e ,d ,a  limit 3;
    e     |  d  |  a  
----------+-----+-----
 col_e1   |   2 |   1
 col_e10  |  11 |  10
 col_e100 | 101 | 100
(3 rows)

-- Backward indexscan with offset and without limit
explain (costs off) select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e desc,d nulls first,a desc offset 9990;
                                                  QUERY PLAN
--------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d, a
         ->  Index Only Scan Backward using dir_index_eda on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(5 rows)

select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e desc,d nulls first,a desc offset 9997;
     e     |  d   |  a   
-----------+------+------
 col_e1000 | 1001 | 1000
 col_e100  |  101 |  100
 col_e10   |   11 |   10
 col_e1    |    2 |    1
(4 rows)

-- Backward indexscan with offset value in subquery
explain (costs off) select c from test_index_with_sort_directions_on_orderby_limit order by c desc nulls last offset (select 9997);
                                                 QUERY PLAN
------------------------------------------------------------------------------------------------------------
 Limit
   InitPlan 1 (returns $0)  (slice2)
     ->  Result
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: test_index_with_sort_directions_on_orderby_limit.c
         ->  Index Only Scan Backward using dir_index_c on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(7 rows)

select c from test_index_with_sort_directions_on_orderby_limit order by c desc nulls last offset (select 9997);
   c    
--------
 0.9375
  0.625
 0.3125
       
(4 rows)

-- Backward indexscan with limit value in subquery
explain (costs off) select c from test_index_with_sort_directions_on_orderby_limit order by c desc nulls last limit (select 3);
                                                    QUERY PLAN
------------------------------------------------------------------------------------------------------------------
 Limit
   InitPlan 1 (returns $0)  (slice2)
     ->  Result
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: test_index_with_sort_directions_on_orderby_limit.c
         ->  Limit
               ->  Index Only Scan Backward using dir_index_c on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select c from test_index_with_sort_directions_on_orderby_limit order by c desc nulls last limit (select 3);
     c     
-----------
      3125
 3124.6875
  3124.375
(3 rows)

-- order by on a non-index columns, should use SeqScan
explain (costs off) select d from test_index_with_sort_directions_on_orderby_limit order by d limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: d
         ->  Limit
               ->  Sort
                     Sort Key: d
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select d from test_index_with_sort_directions_on_orderby_limit order by d limit 3;
 d 
---
 2
 3
 4
(3 rows)

explain (costs off) select a,e from test_index_with_sort_directions_on_orderby_limit order by a,e limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a, e
         ->  Limit
               ->  Sort
                     Sort Key: a, e
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select a,e from test_index_with_sort_directions_on_orderby_limit order by a,e limit 3;
 a |   e    
---+--------
 1 | col_e1
 2 | col_e2
 3 | col_e3
(3 rows)

explain (costs off) select d,a from test_index_with_sort_directions_on_orderby_limit order by d,a desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: d, a
         ->  Limit
               ->  Sort
                     Sort Key: d, a DESC
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select d,a from test_index_with_sort_directions_on_orderby_limit order by d,a desc limit 3;
 d | a 
---+---
 2 | 1
 3 | 2
 4 | 3
(3 rows)

explain (costs off) select d,c from test_index_with_sort_directions_on_orderby_limit order by d desc,c limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: d, c
         ->  Limit
               ->  Sort
                     Sort Key: d DESC, c
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select d,c from test_index_with_sort_directions_on_orderby_limit order by d desc,c limit 3;
   d   |     c     
-------+-----------
       |          
 10001 |      3125
 10000 | 3124.6875
(3 rows)

-- order by on covering index, should use Backward IndexScan
explain (costs off) select e from test_index_with_sort_directions_on_orderby_limit order by e desc limit 3;
                                                     QUERY PLAN
--------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e
         ->  Limit
               ->  Index Only Scan Backward using dir_index_eda on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select e from test_index_with_sort_directions_on_orderby_limit order by e desc limit 3;
     e     
-----------
 
 col_e9999
 col_e9998
(3 rows)

-- order by on covering index with included column, should use SeqScan
explain (costs off) select e,b from test_index_with_sort_directions_on_orderby_limit order by e, b limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, b
         ->  Limit
               ->  Sort
                     Sort Key: e, b
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select e,b from test_index_with_sort_directions_on_orderby_limit order by e,b limit 3;
    e     |    b     
----------+----------
 col_e1   | col_b1
 col_e10  | col_b10
 col_e100 | col_b100
(3 rows)

-- check if IndexOnlyScan Forward/Backward is picked when required
set optimizer_enable_indexscan to off;
-- should use IndexOnlyScan Forward
explain (costs off) select b from test_index_with_sort_directions_on_orderby_limit order by b desc limit 3;
                                               QUERY PLAN
---------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b
         ->  Limit
               ->  Index Only Scan using dir_index_b on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select b from test_index_with_sort_directions_on_orderby_limit order by b desc limit 3;
     b     
-----------
 
 col_b9999
 col_b9998
(3 rows)

explain (costs off) select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e, d desc nulls last limit 3;
                                                QUERY PLAN
-----------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d
         ->  Limit
               ->  Index Only Scan using dir_index_eda on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e, d desc nulls last limit 3;
    e     |  d  |  a  
----------+-----+-----
 col_e1   |   2 |   1
 col_e10  |  11 |  10
 col_e100 | 101 | 100
(3 rows)

-- should use IndexOnlyScan Backward
explain (costs off) select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e desc,d nulls first,a desc limit 3;
                                                     QUERY PLAN
--------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d, a
         ->  Limit
               ->  Index Only Scan Backward using dir_index_eda on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(6 rows)

select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e desc,d nulls first,a desc limit 3;
     e     |   d   |  a   
-----------+-------+------
           |       |     
 col_e9999 | 10000 | 9999
 col_e9998 |  9999 | 9998
(3 rows)

-- reset index scan
set optimizer_enable_indexscan to on;
DROP TABLE test_index_with_sort_directions_on_orderby_limit;
-- check if DynamicSeqScan is used for partition tables.
CREATE TABLE test_partition_table(a int, b int, c float) DISTRIBUTED BY (a) PARTITION BY range(a) (start (0) end(100) every(20));
CREATE INDEX part_index_a ON test_partition_table using btree(a);
INSERT INTO test_partition_table SELECT i, i+3, i/4.2 from generate_series(1,99) i;
ANALYZE test_partition_table;
explain (costs off) select a from test_partition_table order by a limit 3;
                               QUERY PLAN
------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: test_partition_table_1_prt_1.a
         ->  Limit
               ->  Sort
                     Sort Key: test_partition_table_1_prt_1.a
                     ->  Append
                           ->  Seq Scan on test_partition_table_1_prt_1
                           ->  Seq Scan on test_partition_table_1_prt_2
                           ->  Seq Scan on test_partition_table_1_prt_3
                           ->  Seq Scan on test_partition_table_1_prt_4
                           ->  Seq Scan on test_partition_table_1_prt_5
 Optimizer: Postgres query optimizer
(13 rows)

select a from test_partition_table order by a limit 3;
 a 
---
 1
 2
 3
(3 rows)

